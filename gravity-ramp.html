<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Great Gravity Race</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { background-color: #f8fafc; }
        /* Smooth transitions for bars */
        .transition-width { transition-property: width; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICON COMPONENTS (Inline SVGs to replace Lucide dependency) ---
        const IconBase = ({ children, color = "currentColor", size = 24, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                {children}
            </svg>
        );

        const Play = (props) => <IconBase {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></IconBase>;
        const Pause = (props) => <IconBase {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></IconBase>;
        const Zap = (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></IconBase>;
        const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></IconBase>;
        const Info = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></IconBase>;


        // --- Constants & Physics Utilities ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const SIM_STEPS_PER_FRAME = 20; // High precision steps
        const PIXELS_PER_METER = 100; // Scale factor for physics

        // Ramp Types
        const RAMP_TYPES = {
            STRAIGHT: 'straight',
            CONVEX: 'convex',
            DEEP: 'deep',
            CYCLOID: 'cycloid',
        };

        // Configuration for visuals
        const RAMP_CONFIG = {
            [RAMP_TYPES.STRAIGHT]: { label: 'Straight Line', color: '#3b82f6' }, // Blue
            [RAMP_TYPES.CONVEX]: { label: 'Extreme Outward', color: '#ef4444' }, // Red
            [RAMP_TYPES.DEEP]: { label: 'Extreme Inward', color: '#eab308' }, // Yellow
            [RAMP_TYPES.CYCLOID]: { label: 'Brachistochrone', color: '#22c55e' }, // Green
        };

        // --- MATH UTILS FOR CYCLOID ---
        // We need to find theta_max such that (theta - sin(theta)) / (1 - cos(theta)) = W / H
        // We solve this numerically using Newton-Raphson
        const solveCycloidTheta = (width, height) => {
            const targetRatio = width / height;
            let theta = Math.PI; // Initial guess
            
            for (let i = 0; i < 10; i++) {
                const numerator = theta - Math.sin(theta);
                const denominator = 1 - Math.cos(theta);
                const f = (numerator / denominator) - targetRatio;
                
                // Derivative roughly approximation or separate terms
                // It's cleaner to just do simple iterations or binary search if needed, 
                // but Newton is fast.
                // d/dtheta [ (theta - sin theta) / (1 - cos theta) ]
                // = [ (1 - cos)(1 - cos) - (theta - sin)(sin) ] / (1 - cos)^2
                const fPrime = ((denominator * denominator) - (numerator * Math.sin(theta))) / (denominator * denominator);
                
                if (Math.abs(f) < 0.0001) break;
                theta = theta - f / fPrime;
            }
            return theta;
        };

        // --- Curve Generation Functions ---
        const generatePoints = (type, width, height, segments = 400) => {
            const points = [];
            
            // Pre-calculate Cycloid Parameters if needed
            let cycloidR = 0;
            let cycloidThetaMax = 0;
            if (type === RAMP_TYPES.CYCLOID) {
                cycloidThetaMax = solveCycloidTheta(width, height);
                // y_max = height = R(1 - cos(theta_max))
                cycloidR = height / (1 - Math.cos(cycloidThetaMax));
            }

            for (let i = 0; i <= segments; i++) {
                const t = i / segments; 
                let x = 0;
                let y = 0;

                switch (type) {
                case RAMP_TYPES.STRAIGHT:
                    x = t * width;
                    y = (1 - t) * height;
                    break;

                case RAMP_TYPES.CONVEX:
                    // Adjusted Convex
                    x = t * width;
                    const term = Math.max(0, 1 - Math.pow(t, 2));
                    const circlePart = Math.sqrt(term);
                    y = height * circlePart; 
                    break;

                case RAMP_TYPES.DEEP:
                    x = t * width;
                    y = height * Math.pow(1 - t, 5); 
                    break;

                case RAMP_TYPES.CYCLOID:
                    // True Parametric Cycloid
                    // Inverted: Start at (0, Height), go down.
                    // Standard cycloid: x = R(th - sin th), Y_drop = R(1 - cos th)
                    // Our Y = Height - Y_drop
                    const theta = t * cycloidThetaMax;
                    x = cycloidR * (theta - Math.sin(theta));
                    const yDrop = cycloidR * (1 - Math.cos(theta));
                    y = height - yDrop;
                    break;
                    
                default:
                    x = t * width;
                    y = (1 - t) * height;
                }
                
                // Hard force start and end points for clean alignment
                if (i === 0) { x = 0; y = height; }
                if (i === segments) { x = width; y = 0; }
                
                points.push({ x, y });
            }
            return points;
        };

        // --- Helper Functions ---
        const toScreenY = (val) => CANVAS_HEIGHT - val + 20; 
        const toScreenX = (val) => val + 20;

        // --- Main Component ---
        function RampSimulation() {
            // -- State --
            const [isPlaying, setIsPlaying] = useState(false);
            const [showAll, setShowAll] = useState(true);
            const [selectedRamp, setSelectedRamp] = useState(RAMP_TYPES.CYCLOID);
            
            // Physics Parameters
            const [gravity, setGravity] = useState(9.8);
            const [frictionCoef, setFrictionCoef] = useState(0.0);
            const [rampHeight, setRampHeight] = useState(300);
            const [timeScale, setTimeScale] = useState(1.0);
            
            // Simulation State
            const [objects, setObjects] = useState([]);
            const [paths, setPaths] = useState({});
            const reqRef = useRef();
            const lastTimeRef = useRef();

            // Initialize Paths & Objects
            useEffect(() => {
                resetSimulation();
            }, [rampHeight, showAll, selectedRamp]);

            const resetSimulation = () => {
                setIsPlaying(false);
                if (reqRef.current) cancelAnimationFrame(reqRef.current);
                
                // Generate paths
                const newPaths = {};
                Object.values(RAMP_TYPES).forEach(type => {
                newPaths[type] = generatePoints(type, CANVAS_WIDTH, rampHeight);
                });
                setPaths(newPaths);

                // Initial Energy Total (m*g*h)
                const initialHeightMeters = rampHeight / PIXELS_PER_METER;
                const initialTotalEnergy = gravity * initialHeightMeters;

                // Create objects
                const typesToCreate = showAll ? Object.values(RAMP_TYPES) : [selectedRamp];
                const newObjects = typesToCreate.map(type => ({
                id: type,
                type: type,
                x: 0,
                y: rampHeight,
                velocity: 0,
                distanceTraveled: 0,
                segmentIndex: 0,
                segmentProgress: 0,
                finished: false,
                finishTime: 0,
                elapsedTime: 0,
                energy: { 
                    pe: initialTotalEnergy, 
                    ke: 0, 
                    heat: 0, 
                    total: initialTotalEnergy 
                }
                }));

                setObjects(newObjects);
                lastTimeRef.current = null;
            };

            // --- Physics Engine ---
            const updatePhysics = (timestamp) => {
                if (!lastTimeRef.current) lastTimeRef.current = timestamp;
                const dtReal = (timestamp - lastTimeRef.current) / 1000;
                lastTimeRef.current = timestamp;

                if (!isPlaying) return;

                const dt = Math.min(dtReal, 0.05) * timeScale;

                setObjects(prevObjs => {
                const nextObjs = prevObjs.map(obj => {
                    if (obj.finished) return obj;

                    let { velocity, segmentIndex, segmentProgress, elapsedTime, x, y } = obj;
                    const path = paths[obj.type];

                    if (!path || path.length === 0) return obj;

                    const subStepDt = dt / SIM_STEPS_PER_FRAME;
                    
                    for (let s = 0; s < SIM_STEPS_PER_FRAME; s++) {
                    if (segmentIndex >= path.length - 1) break;

                    const p1 = path[segmentIndex];
                    const p2 = path[segmentIndex + 1];

                    const dx = p2.x - p1.x;
                    const drop = p1.y - p2.y; // Positive if falling
                    const len = Math.sqrt(dx * dx + drop * drop);
                    
                    if (len <= 0.0001) {
                        segmentIndex++;
                        continue;
                    }

                    const sinTheta = drop / len; 
                    const cosTheta = Math.abs(dx) / len;

                    // Forces
                    const accelGravity = gravity * sinTheta * PIXELS_PER_METER;
                    const accelFriction = frictionCoef * gravity * cosTheta * PIXELS_PER_METER;

                    let accel = accelGravity;

                    // Start-up Nudge for flat sections
                    if (elapsedTime < 0.1 && velocity < 5) {
                        if (frictionCoef > 0) {
                            accel = accelGravity + 10; 
                        }
                    } else {
                        if (velocity > 0) accel -= accelFriction;
                        else if (velocity < 0) accel += accelFriction;
                    }

                    // Update Velocity
                    velocity += accel * subStepDt;
                    if (velocity < 0) velocity = 0;

                    // Update Position
                    const stepDist = velocity * subStepDt;
                    const progressAdded = stepDist / len;
                    segmentProgress += progressAdded;
                    
                    if (segmentProgress >= 1) {
                        segmentIndex++;
                        segmentProgress = 0; 
                    }
                    
                    elapsedTime += subStepDt;
                    }

                    // Post-Step Updates
                    let isFinished = false;
                    let finalTime = obj.finishTime;

                    if (segmentIndex >= path.length - 1) {
                    isFinished = true;
                    finalTime = elapsedTime;
                    const lastP = path[path.length - 1];
                    x = lastP.x;
                    y = lastP.y; 
                    
                    // Force theoretical final velocity if no friction (Conservation of Energy check)
                    if (frictionCoef === 0) {
                        const h_total_m = rampHeight / PIXELS_PER_METER;
                        const theoreticalV_m = Math.sqrt(2 * gravity * h_total_m);
                        velocity = theoreticalV_m * PIXELS_PER_METER;
                    }
                    } else {
                    // Safe interpolation
                    if (path[segmentIndex] && path[segmentIndex+1]) {
                        const p1 = path[segmentIndex];
                        const p2 = path[segmentIndex + 1];
                        x = p1.x + (p2.x - p1.x) * segmentProgress;
                        y = p1.y + (p2.y - p1.y) * segmentProgress;
                    }
                    }

                    // Energy Calculation
                    const h_current_m = y / PIXELS_PER_METER;
                    const v_current_m = velocity / PIXELS_PER_METER;

                    const pe = gravity * h_current_m; 
                    const ke = 0.5 * v_current_m * v_current_m; 
                    
                    const displayPE = isFinished ? 0 : pe;

                    let heat = obj.energy.total - (displayPE + ke);
                    if (heat < 0.01) heat = 0;

                    return {
                    ...obj,
                    x,
                    y: isFinished ? 0 : y,
                    velocity,
                    segmentIndex,
                    segmentProgress,
                    elapsedTime,
                    finished: isFinished,
                    finishTime: finalTime,
                    energy: { ...obj.energy, pe: displayPE, ke, heat }
                    };
                });

                if (nextObjs.every(o => o.finished)) setIsPlaying(false);
                return nextObjs;
                });

                reqRef.current = requestAnimationFrame(updatePhysics);
            };

            useEffect(() => {
                if (isPlaying) {
                reqRef.current = requestAnimationFrame(updatePhysics);
                } else {
                cancelAnimationFrame(reqRef.current);
                }
                return () => cancelAnimationFrame(reqRef.current);
            }, [isPlaying]);

            return (
                <div className="flex flex-col w-full max-w-5xl mx-auto p-4 bg-slate-50 rounded-xl shadow-lg font-sans text-slate-800 mt-10">
                
                {/* Header */}
                <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                    <div>
                    <h1 className="text-2xl font-bold text-slate-900 flex items-center gap-2">
                        <Zap className="text-yellow-500 fill-yellow-500" />
                        The Great Gravity Race
                    </h1>
                    <p className="text-sm text-slate-500 mt-1">
                        Compare how ramp shape affects descent time and velocity.
                    </p>
                    </div>
                    <div className="flex gap-2 mt-4 md:mt-0">
                    <button 
                        onClick={() => setIsPlaying(!isPlaying)}
                        className={`flex items-center gap-2 px-6 py-2 rounded-full font-bold transition-all ${
                        isPlaying 
                            ? 'bg-orange-100 text-orange-600 hover:bg-orange-200' 
                            : 'bg-blue-600 text-white hover:bg-blue-700 shadow-md hover:shadow-lg'
                        }`}
                    >
                        {isPlaying ? <Pause size={18} /> : <Play size={18} />}
                        {isPlaying ? 'Pause' : 'Start Race'}
                    </button>
                    <button 
                        onClick={resetSimulation}
                        className="p-2 bg-slate-200 hover:bg-slate-300 rounded-full text-slate-600 transition-colors"
                        title="Reset"
                    >
                        <RotateCcw size={20} />
                    </button>
                    </div>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    
                    {/* Canvas Area */}
                    <div className="lg:col-span-2 relative bg-white rounded-xl shadow-inner border border-slate-200 overflow-hidden" style={{ height: CANVAS_HEIGHT + 60 }}>
                    <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
                        {objects.map(obj => {
                        const config = RAMP_CONFIG[obj.type] || { label: 'Unknown', color: '#000' };
                        const labelText = config.label.split(' ')[0] || 'Ramp';
                        const timeDisplay = obj.finished 
                            ? Number(obj.finishTime || 0).toFixed(2) + 's'
                            : Number(obj.elapsedTime || 0).toFixed(2) + 's';

                        return (
                            <div key={obj.id} className="bg-white/90 backdrop-blur px-3 py-1 rounded shadow text-xs font-mono flex items-center justify-between min-w-[140px] border-l-4" style={{ borderColor: config.color }}>
                            <span>{labelText}</span>
                            <span className="font-bold">{timeDisplay}</span>
                            </div>
                        );
                        })}
                    </div>

                    <svg width="100%" height="100%" viewBox={`0 0 ${CANVAS_WIDTH + 50} ${CANVAS_HEIGHT + 50}`} className="absolute top-0 left-0">
                        {Object.keys(paths).map(type => {
                        const isVisible = showAll || type === selectedRamp;
                        if (!isVisible) return null;
                        
                        const pts = paths[type];
                        if (!pts || pts.length === 0) return null;

                        const pathD = pts.map((p, i) => `${i === 0 ? 'M' : 'L'} ${toScreenX(p.x)} ${toScreenY(p.y)}`).join(' ');
                        const config = RAMP_CONFIG[type] || { color: '#000' };
                        
                        return (
                            <g key={type}>
                                <path d={pathD} fill="none" stroke={config.color} strokeWidth={type === selectedRamp || showAll ? 4 : 1} strokeOpacity={showAll || type === selectedRamp ? 1 : 0.2} strokeLinecap="round" />
                                <line x1={20} y1={toScreenY(0)} x2={CANVAS_WIDTH+20} y2={toScreenY(0)} stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4 4" />
                            </g>
                        );
                        })}
                        {objects.map(obj => {
                        const isVisible = showAll || obj.type === selectedRamp;
                        if (!isVisible) return null;
                        
                        const config = RAMP_CONFIG[obj.type] || { color: '#000' };
                        const cx = toScreenX(obj.x);
                        const cy = toScreenY(obj.y);
                        
                        if (isNaN(cx) || isNaN(cy)) return null;

                        return (
                            <g key={obj.id} style={{ transform: `translate(${cx}px, ${cy}px)` }}>
                                <circle r="8" fill={config.color} stroke="white" strokeWidth="2" />
                            </g>
                        );
                        })}
                    </svg>
                    </div>

                    {/* Controls & Stats */}
                    <div className="flex flex-col gap-4">
                    <div className="bg-white p-4 rounded-xl border border-slate-200">
                        <h2 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                        <Settings size={14} /> Configuration
                        </h2>
                        {/* Toggles */}
                        <div className="flex p-1 bg-slate-100 rounded-lg mb-4">
                        <button onClick={() => { setShowAll(true); resetSimulation(); }} className={`flex-1 py-1 text-xs font-semibold rounded-md transition-colors ${showAll ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>Race Mode</button>
                        <button onClick={() => { setShowAll(false); resetSimulation(); }} className={`flex-1 py-1 text-xs font-semibold rounded-md transition-colors ${!showAll ? 'bg-white shadow text-blue-600' : 'text-slate-500'}`}>Single View</button>
                        </div>
                        {!showAll && (
                        <div className="mb-4">
                            <select value={selectedRamp} onChange={(e) => { setSelectedRamp(e.target.value); resetSimulation(); }} className="w-full mt-1 p-2 bg-slate-50 border border-slate-200 rounded text-sm">
                            {Object.entries(RAMP_CONFIG).map(([key, conf]) => (<option key={key} value={key}>{conf.label}</option>))}
                            </select>
                        </div>
                        )}
                        {/* Sliders */}
                        <div className="space-y-4">
                        <div>
                            <div className="flex justify-between text-xs mb-1"><span className="font-semibold text-slate-600">Ramp Height</span><span className="text-slate-400">{rampHeight}px</span></div>
                            <input type="range" min="100" max="380" step="10" value={rampHeight} onChange={(e) => setRampHeight(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                        </div>
                        <div>
                            <div className="flex justify-between text-xs mb-1"><span className="font-semibold text-slate-600">Friction (Î¼)</span><span className={`font-mono ${frictionCoef > 0 ? 'text-red-500 font-bold' : 'text-slate-400'}`}>{frictionCoef.toFixed(2)}</span></div>
                            <input type="range" min="0" max="0.5" step="0.01" value={frictionCoef} onChange={(e) => { setFrictionCoef(Number(e.target.value)); setIsPlaying(false); }} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-red-500" />
                        </div>
                        <div>
                            <div className="flex justify-between text-xs mb-1"><span className="font-semibold text-slate-600">Time Scale</span><span className="text-slate-400">{timeScale.toFixed(1)}x</span></div>
                            <input type="range" min="0.1" max="2.0" step="0.1" value={timeScale} onChange={(e) => setTimeScale(Number(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-green-600" />
                        </div>
                        </div>
                    </div>

                    <div className="bg-white p-4 rounded-xl border border-slate-200 flex-1">
                        <h2 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                            Energy Analysis
                        </h2>
                        <div className="space-y-4 overflow-y-auto max-h-[300px]">
                        {objects.map(obj => {
                            if (!showAll && obj.type !== selectedRamp) return null;
                            
                            const config = RAMP_CONFIG[obj.type] || { label: '?', color: '#000' };
                            const totalE = obj.energy.total || 1; 
                            
                            const pctPE = Math.max(0, Math.min(100, (obj.energy.pe / totalE) * 100));
                            const pctKE = Math.max(0, Math.min(100, (obj.energy.ke / totalE) * 100));
                            const pctHeat = Math.max(0, Math.min(100, (obj.energy.heat / totalE) * 100));
                            
                            const velocityDisplay = (obj.velocity / PIXELS_PER_METER).toFixed(2);

                            return (
                            <div key={obj.id} className="border-b border-slate-100 pb-3 last:border-0">
                                <div className="flex justify-between items-center mb-1">
                                    <span className="text-sm font-bold" style={{ color: config.color }}>{config.label}</span>
                                    <span className="text-xs font-mono bg-slate-100 px-1 rounded">{velocityDisplay} m/s</span>
                                </div>
                                <div className="h-4 w-full bg-slate-200 rounded-full overflow-hidden flex">
                                    <div style={{ width: `${pctPE}%` }} className="bg-blue-500" title="PE" />
                                    <div style={{ width: `${pctKE}%` }} className="bg-green-500" title="KE" />
                                    <div style={{ width: `${pctHeat}%` }} className="bg-red-500" title="Thermal" />
                                </div>
                                <div className="flex justify-between text-[10px] text-slate-400 mt-1">
                                    <span className="text-blue-600">PE</span>
                                    <span className="text-green-600">KE</span>
                                    <span className="text-red-600">Heat</span>
                                </div>
                            </div>
                            )
                        })}
                        </div>
                    </div>
                    </div>
                </div>

                <div className="mt-6 p-4 bg-indigo-50 rounded-lg text-sm text-indigo-900 border border-indigo-100">
                    <h3 className="font-bold flex items-center gap-2 mb-2"><Info size={16} /> How to interpret results:</h3>
                    <ul className="list-disc pl-5 space-y-1 opacity-80">
                    <li><strong>Zero Friction:</strong> All blocks finish with <strong>identical final velocity</strong>. This proves Conservation of Energy.</li>
                    <li><strong>Energy Bars:</strong> Blue is Potential (Height), Green is Kinetic (Speed), Red is Thermal (Lost to Friction).</li>
                    <li><strong>The Race:</strong> The Cycloid (Green) wins because it converts PE to KE early, maintaining high average speed. The Red Convex ramp loses because it accelerates too late.</li>
                    </ul>
                </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RampSimulation />);
    </script>
</body>
</html>
